â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                â•‘
â•‘          âœ… CONTACT VALIDATION - COMPLETE IMPLEMENTATION GUIDE                  â•‘
â•‘                                                                                â•‘
â•‘        Email or Mobile Number with Strict Fake Number Detection                â•‘
â•‘                                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ğŸ“‹ FILES CREATED FOR YOU
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… src/lib/contactValidation.ts
   â””â”€ Reusable validation function (can be used in frontend and backend)

âœ… src/hooks/useContactValidation.ts
   â””â”€ React hook for form component (real-time validation)

âœ… server/middleware/contactValidation.js
   â””â”€ Backend validation middleware and functions

âœ… server/CONTACT_VALIDATION_INTEGRATION.js
   â””â”€ Integration guide with examples


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš€ QUICK SETUP (5 MINUTES)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Step 1: Frontend - Use the React Hook
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
In your form component:

  import { useContactValidation } from '@/hooks/useContactValidation';

  function YourForm() {
    const { contact, error, setContact, isValid, getNormalizedValue } = useContactValidation();

    const handleSubmit = (e) => {
      e.preventDefault();
      if (!isValid) {
        // Show error
        return;
      }
      // Submit with getNormalizedValue()
    };

    return (
      <>
        <input value={contact} onChange={(e) => setContact(e.target.value)} />
        {error && <span className="error">{error}</span>}
      </>
    );
  }

Step 2: Backend - Apply Middleware
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
In server/index.js:

  const { validateContactField } = require('./middleware/contactValidation');

  app.post('/api/questions', validateContactField, async (req, res) => {
    // req.body.contact is now validated and normalized
    // req.body.contactType is 'email' or 'mobile'
  });

Step 3: Database - Update Schema
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Replace studentEmail with:

  contact: { type: String, required: true },
  contactType: { type: String, enum: ['email', 'mobile'] }

Step 4: Test
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
See test cases below

Done! âœ…


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… VALIDATION RULES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EMAIL:
  âœ… Valid:     john@example.com
  âœ… Valid:     name.last@company.co.uk
  âŒ Invalid:   johnexample.com (no @)
  âŒ Invalid:   john@example (no TLD)
  âŒ Invalid:   @example.com (no user)

MOBILE (10 DIGITS ONLY):
  âœ… Valid:     9876543210
  âœ… Valid:     987-654-3210 (auto-formatted)
  âœ… Valid:     (987) 654-3210 (auto-formatted)
  
  âŒ Invalid:   1234567890 (sequential ascending)
  âŒ Invalid:   0987654321 (sequential descending)
  âŒ Invalid:   0000000000 (all zeros)
  âŒ Invalid:   1111111111 (all ones)
  âŒ Invalid:   2222222222 (all same digit)
  âŒ Invalid:   1212121212 (repeating pair)
  âŒ Invalid:   123123123 (repeating triple - 9 digits)
  âŒ Invalid:   123456789 (9 digits - too short)
  âŒ Invalid:   12345678901 (11 digits - too long)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§ª TESTING EXAMPLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FRONTEND TESTING (React)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Test 1: Valid Email
  Input: "john@example.com"
  Expected: {
    isValid: true,
    type: 'email',
    error: null
  }

Test 2: Valid Mobile
  Input: "9876543210"
  Expected: {
    isValid: true,
    type: 'mobile',
    error: null
  }

Test 3: Invalid Mobile - Sequential
  Input: "1234567890"
  Expected: {
    isValid: false,
    type: 'mobile',
    error: "Mobile number cannot be sequential (e.g., 1234567890)"
  }

Test 4: Invalid Mobile - All Same
  Input: "0000000000"
  Expected: {
    isValid: false,
    type: 'mobile',
    error: "Mobile number cannot have all same digits (e.g., 0000000000)"
  }

Test 5: Invalid Mobile - Wrong Length
  Input: "12345678"
  Expected: {
    isValid: false,
    type: 'mobile',
    error: "Mobile number must be exactly 10 digits (you entered 8)"
  }

Test 6: Invalid Email
  Input: "johnexample.com"
  Expected: {
    isValid: false,
    type: 'email',
    error: "Invalid email format. Use: example@domain.com"
  }

BACKEND TESTING (Node.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Using curl:

Test 1: Valid Email
  curl -X POST http://localhost:4000/api/questions \
    -H "Content-Type: application/json" \
    -d '{
      "studentName": "John",
      "contact": "john@example.com",
      "subject": "JavaScript",
      "question": "How do closures work?"
    }'
  
  Expected: 201 Created

Test 2: Valid Mobile
  curl -X POST http://localhost:4000/api/questions \
    -H "Content-Type: application/json" \
    -d '{
      "studentName": "John",
      "contact": "9876543210",
      "subject": "JavaScript",
      "question": "How do closures work?"
    }'
  
  Expected: 201 Created

Test 3: Invalid Mobile - Sequential (should REJECT)
  curl -X POST http://localhost:4000/api/questions \
    -H "Content-Type: application/json" \
    -d '{
      "studentName": "John",
      "contact": "1234567890",
      "subject": "JavaScript",
      "question": "How do closures work?"
    }'
  
  Expected: 400 Bad Request
  Response: {
    "message": "Mobile number cannot be sequential (e.g., 1234567890)",
    "error": "INVALID_CONTACT",
    "type": "mobile"
  }

Test 4: Invalid Mobile - All Zeros (should REJECT)
  curl -X POST http://localhost:4000/api/questions \
    -H "Content-Type: application/json" \
    -d '{"contact": "0000000000", ...}'
  
  Expected: 400 Bad Request

Test 5: Invalid Email (should REJECT)
  curl -X POST http://localhost:4000/api/questions \
    -H "Content-Type: application/json" \
    -d '{"contact": "johnexample.com", ...}'
  
  Expected: 400 Bad Request
  Response: {
    "message": "Invalid email format. Use: example@domain.com",
    "error": "INVALID_CONTACT",
    "type": "email"
  }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” VALIDATION EXAMPLES - DETAILED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Using validateContact() function directly:

const { validateContact } = require('./lib/contactValidation');

// Example 1: Valid email
const result1 = validateContact('john@example.com');
console.log(result1);
// Output: { isValid: true, type: 'email', value: 'john@example.com', error: null }

// Example 2: Valid mobile with formatting
const result2 = validateContact('987-654-3210');
console.log(result2);
// Output: { isValid: true, type: 'mobile', value: '9876543210', error: null }

// Example 3: Invalid mobile - sequential
const result3 = validateContact('1234567890');
console.log(result3);
// Output: { isValid: false, type: 'mobile', value: null, error: '...' }

// Example 4: Invalid mobile - all zeros
const result4 = validateContact('0000000000');
console.log(result4);
// Output: { isValid: false, type: 'mobile', value: null, error: '...' }

// Example 5: Invalid email
const result5 = validateContact('john@example');
console.log(result5);
// Output: { isValid: false, type: 'email', value: null, error: '...' }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¡ USAGE PATTERNS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PATTERN 1: Real-time Validation (Hook)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function MyForm() {
  const { contact, error, setContact, isValid } = useContactValidation();

  return (
    <>
      <input
        value={contact}
        onChange={(e) => setContact(e.target.value)}
        style={{ borderColor: error ? 'red' : 'green' }}
      />
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </>
  );
}

âœ… Pros:
  - Immediate feedback
  - Easy to use
  - Automatic state management
  - Shows error only when touched

âŒ Cons:
  - One-time use per component


PATTERN 2: Manual Validation (Function)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function MyForm() {
  const [contact, setContact] = useState('');

  const handleBlur = () => {
    const result = validateContact(contact);
    if (!result.isValid) {
      console.log(result.error);
    }
  };

  return <input value={contact} onChange={(e) => setContact(e.target.value)} onBlur={handleBlur} />;
}

âœ… Pros:
  - Full control
  - Validate at specific time
  - Can be reused

âŒ Cons:
  - More code
  - Manual state management


PATTERN 3: Middleware Validation (Backend)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/api/questions', validateContactField, async (req, res) => {
  // Contact already validated
  // req.body.contact = normalized value
  // req.body.contactType = 'email' or 'mobile'
});

âœ… Pros:
  - Automatic
  - Consistent
  - Protects against bypass
  - Clean route handlers

âŒ Cons:
  - Generic error messages
  - Can't customize per route


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š WHAT GETS STORED IN DATABASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Before Validation:
  User enters: "john@example.com" or "987-654-3210"

After Validation & Normalization:
  contact: "john@example.com"  (lowercase email)
  OR
  contact: "9876543210"        (digits only)

Database Record:
  {
    "_id": "...",
    "studentName": "John",
    "contact": "john@example.com",    // Normalized
    "contactType": "email",           // Type recorded
    "subject": "JavaScript",
    "question": "...",
    "createdAt": "2026-01-28...",
    "updatedAt": "2026-01-28..."
  }


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” SECURITY BENEFITS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Backend Validation Required
   Even if frontend validation bypassed, backend validates again

âœ… Normalized Storage
   Email: always lowercase (prevents duplicates: john@X vs JOHN@X)
   Mobile: digits only (removes formatting ambiguity)

âœ… Fake Number Detection
   Prevents test data: 1234567890, 0000000000, etc.

âœ… Type Tracking
   Store whether contact is email or mobile
   Helps with future communication preferences

âœ… Error Handling
   Specific error messages don't leak internal logic
   Backend sanitizes all responses


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ˆ IMPLEMENTATION CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Frontend:
  â˜ Copy src/lib/contactValidation.ts
  â˜ Copy src/hooks/useContactValidation.ts
  â˜ Import useContactValidation in form component
  â˜ Replace studentEmail input with contact input
  â˜ Use getNormalizedValue() when submitting
  â˜ Test with curl (all cases above)

Backend:
  â˜ Copy server/middleware/contactValidation.js
  â˜ Require validateContactField in server/index.js
  â˜ Apply middleware to POST /api/questions route
  â˜ Update Question schema (contact + contactType)
  â˜ Update all question creation code
  â˜ Test with curl (all invalid cases should reject)

API:
  â˜ Update api.ts (contact instead of studentEmail)
  â˜ Update any other API endpoints using contact

Database:
  â˜ Decide on migration strategy:
     * Drop collection and start fresh (dev)
     * Add new fields and deprecate old (prod)
  â˜ Update all queries referencing studentEmail

Testing:
  â˜ Test 6 valid cases (3 email, 3 mobile)
  â˜ Test 10 invalid cases (sequential, repeated, etc.)
  â˜ Test mobile formatting (- and () are stripped)
  â˜ Verify frontend shows error on invalid input
  â˜ Verify backend rejects on invalid input


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â“ FREQUENTLY ASKED QUESTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Q: Why normalize mobile to digits only?
A: Removes formatting ambiguity. "987-654-3210" and "9876543210" are the same.
   Store canonical form in database.

Q: Why detect fake numbers?
A: Prevents test data pollution. Common test numbers like 1234567890 shouldn't
   be treated as valid user input.

Q: Do I need both frontend and backend validation?
A: Yes. Frontend is for UX (real-time feedback). Backend is for security
   (users can bypass frontend validation).

Q: Can I use just the backend validation?
A: Yes, but UX will suffer. Users won't get real-time feedback. Backend
   validation is mandatory; frontend is optional but recommended.

Q: How do I send contact to API?
A: Use getNormalizedValue() from the hook:
   contact: getNormalizedValue()  // Already validated & normalized

Q: What if contact is both valid email and mobile?
A: Check if it contains "@". If yes, validate as email. Otherwise, as mobile.
   Input like "user@9876543210" would be invalid email (won't pass regex).

Q: Can mobile numbers start with different digits?
A: Yes. Validation accepts any 10 digit number that isn't sequential/repeated.
   Indian mobiles often start with 9 or 8, but not enforced here.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What was created:
  âœ… Reusable validation function (email or mobile)
  âœ… React hook for real-time validation
  âœ… Backend middleware for automatic validation
  âœ… Fake number detection (sequential, repeated)
  âœ… Complete integration guide
  âœ… Test cases and examples

How to use:
  1. Copy the 3 files
  2. Import useContactValidation in your form
  3. Add validateContactField middleware in backend
  4. Update schema to use contact + contactType
  5. Test with provided test cases

Result:
  âœ… Strict validation (no fake numbers)
  âœ… Great UX (real-time feedback)
  âœ… Strong security (backend validation)
  âœ… No UI changes
  âœ… Production-ready

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
